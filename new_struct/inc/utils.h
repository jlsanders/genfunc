/*======================================*/
/*		  A few utility functions 	  	*/
/*======================================*/
#ifndef UTILS_H
#define UTILS_H

#include <vector>
#include <cmath>
#include <iostream>

typedef std::vector<double> VecDoub;

const double PI = 3.14159265359;
const double Grav = 430091.5694; /* in units kpc, km/s and 10^11 M_solar */
const double TINY = 1e-10;

#define MAX(A,B) A>B?A:B

template<class c>
c Max(const std::vector<c> &a){
	c R = a[0];
	for_each(begin(a),end(a),[&R](c p){if(p>R)R=p;});
	return R;
}

template<class c>
c Min(const std::vector<c> &a){
	c R = a[0];
	for_each(begin(a),end(a),[&R](c p){if(p<R)R=p;});
	return R;
}

template<class c>
void printVector(const std::vector<c> &a){
	for ( unsigned int i=0;i<a.size();i++)std::cout<<a[i]<<" ";
	std::cout<<std::endl;
}

template<class c>
std::vector<c> concatVectors(const std::vector<c> &a, const std::vector<c> &b){
	int p = a.size();
	std::vector<c> Result (p+b.size());
	for(int i=0;i<p;i++)Result[i]=a[i];
	for(int i=0;i<b.size();i++)Result[i+p]=b[i];
	return Result;
}

template<class c>
double Mean(const std::vector<c> &a){
	double R;
	for_each(begin(a),end(a),[&R](c p){R+=p;});
	return ((double)R/(double)a.size());
}

template<class c>
double SD(const std::vector<c> &a){
	double R1, R2;
	for_each(begin(a),end(a),[&R1,&R2](c p){R1+=p;R2+=p*p;});
	int N=a.size();R1/=(double)N;
	return sqrt(R2/N-R1*R1);
}

static double abscissa50[50]={0.0156289844215430828722167,0.0468716824215916316149239,0.0780685828134366366948174,0.1091892035800611150034260,0.1402031372361139732075146,0.1710800805386032748875324,0.2017898640957359972360489,0.2323024818449739696495100,0.2625881203715034791689293,0.2926171880384719647375559,0.3223603439005291517224766,0.3517885263724217209723438,0.3808729816246299567633625,0.4095852916783015425288684,0.4378974021720315131089780,0.4657816497733580422492166,0.4932107892081909335693088,0.5201580198817630566468157,0.5465970120650941674679943,0.5725019326213811913168704,0.5978474702471787212648065,0.6226088602037077716041908,0.6467619085141292798326303,0.6702830156031410158025870,0.6931491993558019659486479,0.7153381175730564464599671,0.7368280898020207055124277,0.7575981185197071760356680,0.7776279096494954756275514,0.7968978923903144763895729,0.8153892383391762543939888,0.8330838798884008235429158,0.8499645278795912842933626,0.8660146884971646234107400,0.8812186793850184155733168,0.8955616449707269866985210,0.9090295709825296904671263,0.9216092981453339526669513,0.9332885350430795459243337,0.9440558701362559779627747,0.9539007829254917428493369,0.9628136542558155272936593,0.9707857757637063319308979,0.9778093584869182885537811,0.9838775407060570154961002,0.9889843952429917480044187,0.9931249370374434596520099,0.9962951347331251491861317,0.9984919506395958184001634,0.9997137267734412336782285};
static double weights50[50]={0.0312554234538633569476425,0.0312248842548493577323765,0.0311638356962099067838183,0.0310723374275665165878102,0.0309504788504909882340635,0.0307983790311525904277139,0.0306161865839804484964594,0.0304040795264548200165079,0.0301622651051691449190687,0.0298909795933328309168368,0.0295904880599126425117545,0.0292610841106382766201190,0.0289030896011252031348762,0.0285168543223950979909368,0.0281027556591011733176483,0.0276611982207923882942042,0.0271926134465768801364916,0.0266974591835709626603847,0.0261762192395456763423087,0.0256294029102081160756420,0.0250575444815795897037642,0.0244612027079570527199750,0.0238409602659682059625604,0.0231974231852541216224889,0.0225312202563362727017970,0.0218430024162473863139537,0.0211334421125276415426723,0.0204032326462094327668389,0.0196530874944353058653815,0.0188837396133749045529412,0.0180959407221281166643908,0.0172904605683235824393442,0.0164680861761452126431050,0.0156296210775460027239369,0.0147758845274413017688800,0.0139077107037187726879541,0.0130259478929715422855586,0.0121314576629794974077448,0.0112251140231859771172216,0.0103078025748689695857821,0.0093804196536944579514182,0.0084438714696689714026208,0.0074990732554647115788287,0.0065469484508453227641521,0.0055884280038655151572119,0.0046244500634221193510958,0.0036559612013263751823425,0.0026839253715534824194396,0.0017093926535181052395294,0.0007346344905056717304063};

inline double GaussLegendreQuad(double (*func)(double, void*),double a,double b, void *p = NULL){
	// Adapted from numerical recipes routine qgaus
	double xm=0.5*(b+a);
	double xr=0.5*(b-a);
	double ss=0.0;
	for (int j=0; j<50; j++){
		double dx=xr*abscissa50[j];
		ss=ss+weights50[j]*(func(xm+dx,p)+func(xm-dx,p));
	}
	return ss*xr;
}

#endif
